% for testing event detection schemes

% --- threshold based (MAD)
if (0)

	threshMult = 4;
	threshStartMult = 0.5*threshMult;
	threshEndMult = 0.5*threshMult;
	minEvDur = 500; % in ms

	dt = mode(diff(s.caTSA.time));
	minEvDur = round(minEvDur/dt); % in ms


  valueMatrix = s.caTSA.dffTimeSeriesArray.valueMatrix;
  
	posValueMatrix = valueMatrix;
	posValueMatrix(find(posValueMatrix <0)) = NaN;

	% get MADs 
	nParams.timeUnit = s.caTSA.timeUnit;
	nParams.method = 'hfMAD';
	nParams.prefiltSizeInSeconds = 1;
  noise = session.timeSeries.computeNoiseS(s.caTSA.time,s.caTSA.dffTimeSeriesArray.valueMatrix, nParams);


	% pooling of MADs?
	activeIdx = find(ismember(s.caTSA.ids,s.caTSA.activeRoiIds));
	inactiveIdx = setdiff(1:length(s.caTSA.ids), activeIdx);
	val = find(~isnan(noise(inactiveIdx)));
	noise(activeIdx) = quantile(noise(inactiveIdx(val)), 0.8);

	% generate a median-subtracted value matrix -- since you are using median absolute deviation based thresh
	medianSubdValueMatrix = valueMatrix-repmat(nanmedian(valueMatrix'),size(valueMatrix,2),1)';

	% call to detectEventsViaThresh
	[peakTimes peakValues startTimes endTimes] = session.calciumTimeSeriesArray.detectEventsViaThresh(medianSubdValueMatrix, ...
		 s.caTSA.time, threshMult*noise, threshStartMult*noise, threshEndMult*noise, minEvDur);

  % ESA
	cesObj = {};
	for i=1:s.caTSA.length()
		newIdStr = ['evnt ' char(s.caTSA.idStrs{i})];
		cesObj{i} = session.calciumEventSeries(peakTimes{i}, [], startTimes{i}, endTimes{i}, ...
		      [], [], peakValues{i}, ...
	        s.caTSA.timeUnit, s.caTSA.ids(i), newIdStr, 0, 'generated by detectEventsViaThresh');
  end
	cesaObj = session.calciumEventSeriesArray(cesObj);

end

% --- iterative template 
if (1)
  dt  = mode(diff(s.caTSA.time));
	dt = dt/1000;

	% get noise
	nParams.timeUnit = s.caTSA.timeUnit;
	nParams.method = 'hfMAD';
	nParams.prefiltSizeInSeconds = 1;
  noise = session.timeSeries.computeNoiseS(s.caTSA.time,s.caTSA.dffTimeSeriesArray.valueMatrix, nParams);

  % 1.4826 MAD to sd


% an167951_2012_05_06_sess.caTSA_02:
% 159: good  'easy' trace
% 1: trace with fast response times
% 3: 'hyper'active neuron (interneuron? still, nice sharp rise)
% 7: another hard one
% 8: ultra sparse
% 9: burst
% 19, 81, 82: silent
% 23: sparse, VERY slow time constant
% 30: fluctuating signal [should these just be treated as indicative of FR?  or with a simple linear kernel?]

  taus = 2*dt:2*dt:100*dt;
  taus = 2*dt:2*dt:50*dt;
	for ei = [3 159 23  8 9 1 7 19 81 82 30]
		%evdet_play(s.caTSA.dffTimeSeriesArray.valueMatrix(ei,:), noise(ei));
		vec = s.caTSA.dffTimeSeriesArray.valueMatrix(ei,:); 
		val = find(~isnan(vec));

		vec(find(isnan(vec))) = 0;

		q_vec(1) = quantile(vec(val),.05);
		q_vec(2) = quantile(vec(val),.95);

		sdThresh = 1.4826*3*noise(ei);
		madThresh = 1.4826*3*noise(ei);
	 
		minRate = 0.025;
		minDff = 0.025;
		expRate = length(find((vec-median(vec)) > noise(ei)))/length(vec)



		n_mat = zeros(length(taus),length(vec));
		c_mat = zeros(length(taus),length(vec));
		n_evs = 0*taus;
		resid = 0*taus;

		ev_prob_thresh = .25;
		
		for t=1:length(taus)
			guessTau = taus(t);
	%		[n_best P_best V_best C_best X] = extern_oopsi_deconv (vec', round(1/0.143), ...
	%				  madThresh, guessTau, minRate, minDff, sdThresh, expRate);
			V.dt = dt;
			V.tau = guessTau;
			P.gam = (1-V.dt/V.tau);
			T = length(vec);

			P.lam = expRate;
			
			[n_best P_best V_best C_best]=extern_fast_oopsi(vec,V,P);

			% quantile adjustment of convolved result . . . (wish I knew what this was!!)
			q_C = [quantile(C_best(val),.05) quantile(C_best(val),.95)];
			C_best = C_best*(diff(q_vec)/diff(q_C));
			C_best = C_best - (q_C(1)+q_vec(1));

			n_mat(t,:) = n_best;
			c_mat(t,:) = C_best;
	 
			n_evs(t) = length(find(n_best > ev_prob_thresh));
			residVec = abs(vec(val) - C_best(val)');

			resid(t) = nanmean(residVec);
			% only consider when resid > 1 SD
%			residVal = find(residVec > 1.4826*noise(ei));
%			resid(t) = nanmean(abs(vec(residVal) - C_best(residVal)'));
		end
	 
		[minres bti] = min(resid);
		if (minres == 0)
			[irr tidx] = min(n_evs(bti));
			bti = bti(tidx);
		else % product is better!
		  % product?  use power for weight?
			score = n_evs.*(resid);
			[irr bti] = min(score);

      % how about minimize # of events for residuals < 1 SD
%			valResid = find(resid < 1.4826*noise(ei));
%     [irr ti] = min(n_evs(valResid));
%			bti = valResid(ti);
		end

		figure ; 
		eidx = find(n_mat(bti,:) > ev_prob_thresh);
		plot(vec); hold on;
		plot(c_mat(bti,:), 'r-');
		plot(eidx,vec(eidx),'g.');
		title(['Tau: ' num2str(taus(bti)) ' Noise: ' num2str(noise(ei))]);
		pause;
	end
end

% --- iterative template O
if (0)
	% get noise
	nParams.timeUnit = s.caTSA.timeUnit;
	nParams.method = 'hfMAD';
	nParams.prefiltSizeInSeconds = 1;
  noise = session.timeSeries.computeNoiseS(s.caTSA.time,s.caTSA.dffTimeSeriesArray.valueMatrix, nParams);

	% pool MADs for active guys
	activeIdx = find(ismember(s.caTSA.ids,s.caTSA.activeRoiIds));
	inactiveIdx = setdiff(1:length(s.caTSA.ids), activeIdx);
	val = find(~isnan(noise(inactiveIdx)));
	noise(activeIdx) = quantile(noise(inactiveIdx(val)), 0.8);

  % FOR NOW
	vec = s.caTSA.dffTimeSeriesArray.valueMatrix(16,:);
	vec = s.caTSA.dffTimeSeriesArray.valueMatrix(159,:);

  % event detection
  nPre = 4
  nRise = 0;
	nDec = 20;
	tauDec = 10;
  tempKern = 1+[zeros(1,nPre-1) linspace(0,1,nRise+1) exp(-1*(1:nDec)/tauDec)];
	tempKern = tempKern/sum(tempKern) ; % normalize yo kernl fool

	% convolve with template kernel . . .
	cvec = conv(vec,tempKern,'same');

	% loop over vector and compute residual ...
	residualVec = vec-cvec;
	fitScore = vec - residualVec; % how much did you gain with fit?

	% plot
	figure;
	subplot(3,1,1);
	plot(vec);
	subplot(3,1,2);
	plot(residualVec);
	subplot(3,1,3);
	plot(fitScore);

	figure;
	plot(vec, 'k-');
	hold on ;
	plot(residualVec,'r-');
	plot(fitScore, 'b-');

	%% noise estimate -- needed for knowing what to accept/reject

  % ESA construction
if (0)
	cesObj = {};
	for i=1:s.caTSA.length()
		newIdStr = ['evnt ' char(s.caTSA.idStrs{i})];
		cesObj{i} = session.calciumEventSeries(peakTimes{i}, [], startTimes{i}, endTimes{i}, ...
		      [], [], peakValues{i}, ...
	        s.caTSA.timeUnit, s.caTSA.ids(i), newIdStr, 0, 'generated by detectEventsViaThresh');
  end
	cesaObj = session.calciumEventSeriesArray(cesObj);
end

end


%% better estimate of noise [timeSeries.getNoiseEstimateS]
if (0)
  valueMatrix = s.caTSA.dffTimeSeriesArray.valueMatrix;
	roiNoise = []; % noise is MAD estimated on low-pass-filter subtracted trace
	dt = mode(diff(s.caTSA.time));
	smoothSize = round(1000/dt); % ASSUME ms - in release fix this
	kern = ones(1,smoothSize);
	kern = kern/sum(kern) ; % normalize the kernel
  for r=1:size(valueMatrix,1)
	  vec = valueMatrix(r,:);
    svec = conv(vec,kern,'same');

		val = find(~isnan(vec));

		vec = vec(val);
		svec = svec(val);

		roiNoise(r) = mad(vec-svec);
	end
end

%% TEMPLATE TESTS
if (0)
  nPre = 2
  nRise = 1;
	nDec = 20;

	tauDec = 10;

  tempVec = [zeros(1,nPre-1) linspace(0,1,nRise+1) exp(-1*(1:nDec)/tauDec)];
	ltv = length(tempVec);
  
	% loop over vector and compute residual ...
	vec = s.caTSA.dffTimeSeriesArray.valueMatrix(3,:);
	residualVec = nan*vec;

  for i=(1:(length(vec)-ltv)) + nPre+nRise
	  i1 = i - (nPre+nRise-1);
	  i2 = i1 + ltv - 1;
		ttempVec = tempVec*vec(i);
	  residualVec(i) = nanmean(vec(i1:i2) - ttempVec); % "unpredicted" component
  end

	fitScore = vec - residualVec; % how much did you gain with fit?

	% plot
	figure;
	subplot(3,1,1);
	plot(vec);
	subplot(3,1,2);
	plot(residualVec);
	subplot(3,1,3);
	plot(fitScore);

	figure;
	plot(vec, 'k-');
	hold on ;
	plot(residualVec,'r-');
	plot(fitScore, 'b-');

	%% noise estimate -- needed for knowing what to accept/reject

end


%% EVAL PLOTTER
if (0)
  figure ; 
	for i=1:s.caTSA.length()
	  s.caTSA.dffTimeSeriesArray.getTimeSeriesByIdx(i).plot();
		hold on;
		cesaObj.getEventSeriesById(s.caTSA.ids(i)).plot([1 0 0]);
		a  = axis;
		axis([a(1) a(2) -1 3]);
	  pause;
		cla
	end
end
