%
% SP 2011 Jan
%
% This will run a single bagger instance generated by a parallel process spawner.
%  Many parameters are execMode specific, so look to 
%  session.session.setupTreeBaggerPar for details.
%
% USAGE:
% 
% bagger_par_singlerun(params)
%
%   params.baseDataFile: where variables like orig_x, etc. are stored
%   params.execMode: 'encoderRF': process output of encoderRF instances
%                    'getGroupFeatureTree': runs ALL neurons for 1 feature encoder
%                    'getCategoryFeatureTree': single neuron, subset of features encoder
%                    'decoderPopSingleFeature': all neurons, single feature decoder
%   params.tempOutputFile: where to put temp output
%   params.optionsTree: the optionsTree structure used by bagger
%
function bagger_par_singlerun(params)
  % 1) load the baseDataFile, setup optionsTree
	load(params.baseDataFile);
  optionsTree = params.optionsTree;

	% 2) behavior based on execMode ...
	disp(['bagger_par_singlerun::exec mode ' params.execMode]);
	switch (params.execMode)
	  case 'encoderRF' % encoder -- can be single neuron tahnks to params.neuronIdx
			resultsFull = encoderRF (x,orig_y,type_vec,neurons(params.neuronIdx),optionsTree);
			disp(['bagger_par_singlerun::output saved to ' params.tempOutputFile]);
			results = resultsFull;
			ni = params.neuronIdx;
			save(params.tempOutputFile, 'results', 'ni');

		case 'getGroupFeatureTree'
			resultsSingleFeature = getGroupFeatureTree(x,orig_y,type_vec,neurons, ...
			  groups,params.singleGroup,optionsTree);
			resultsSingleFeature = getPSTHMultipleGo (orig_x,orig_y,orig_names,'trial_class',...
			  '',optionsTree.minTrials,resultsSingleFeature);  % No multiple - GO information
			resultsSingleFeature = getMetricsEncoder (orig_x,orig_y,y_train,orig_names, ...
			  'trial_class','',optionsTree.minTrials,resultsSingleFeature);   
			resultsSingleFeature.parameters.encoderFeatures.all = nameGroups;
			resultsSingleFeature.parameters.encoderFeatures.groups = groups;
			resultsSingleFeature.parameters.encoderFeatures.activeFeatures = params.singleGroup;

			disp(['bagger_par_singlerun::output saved to ' params.fileToSave]);
			save(params.fileToSave,'resultsSingleFeature');

		case 'getCategoryFeatureTree' % single neuron  via neuronIdx
			resultsSingleCategory = getGroupFeatureTree(x,orig_y,type_vec,neurons(params.neuronIdx), ...
			   regroups,params.singleGroup,optionsTree);
			resultsSingleCategory = getPSTHMultipleGo (orig_x,orig_y,orig_names,'trial_class','', ...
			  optionsTree.minTrials,resultsSingleCategory);  % No multiple - GO information
			resultsSingleCategory = getMetricsEncoder (orig_x,orig_y,y_train,orig_names,'trial_class','', ...
			   optionsTree.minTrials,resultsSingleCategory);   
			resultsSingleCategory.parameters.encoderFeatures.all = reGroupName;
			resultsSingleCategory.parameters.encoderFeatures.groups = regroups;
			resultsSingleCategory.parameters.encoderFeatures.activeFeatures = params.singleGroup;
			resultsSingleCategory.parameters.encoderFeatures.categoryNames = reGroupCategory;

			disp(['bagger_par_singlerun::output saved to ' params.tempOutputFile]);
			results = resultsSingleCategory;
			ni = params.neuronIdx;
			save(params.tempOutputFile,'results', 'ni');

		case 'decoderPopSingleFeature' 
			namesDecoded = params.namesDecoded;

			x = orig_x;
			names = orig_names;
			N_shifts = length(optionsTree.decoder.calciumShifts);
			resultsPopulation = decoderRF (x,y,type_vec_dec,names,names_y, ...
			   namesDecoded,neurons(params.neuronIdx),N_shifts,shiftsPerFeature,optionsTree,weight);    
			resultsPopulation.population = getPSTHDecoderMultipleGo (x,names,namesDecoded,'trial_class', ...
			  '',optionsTree.minTrials,resultsPopulation.parameters.listFeatures,resultsPopulation.population);
			resultsPopulation.population = getMetricsDecoder (x,names,namesDecoded,'trial_class', ...
			  '',optionsTree.minTrials,resultsPopulation.parameters.listFeatures,resultsPopulation.population);   
			resultsPopulation.parameters.decoderFeature.all      = names;
			resultsPopulation.parameters.decoderFeature.original = orig_names;
			resultsPopulation.parameters.decoderFeature.selected = namesDecoded;
			resultsPopulation.parameters.decoderFeature.shifts   = shiftsPerFeature;

			disp(['bagger_par_singlerun::output saved to ' params.fileToSave]);
			save(params.fileToSave,'resultsPopulation');


		case 'decoderSingleCellSingleFeature'
			namesDecoded = params.namesDecoded;

			x = orig_x;
			names = orig_names;
			N_shifts = length(optionsTree.decoder.calciumShifts);

			resultsSingleCell = decoderRF (x,y,type_vec_dec,names,names_y, ...
			   namesDecoded,neurons(params.neuronIdx),N_shifts,shiftsPerFeature,optionsTree,weight);    

			ni = params.neuronIdx;
			save(params.tempOutputFile,'resultsSingleCell', 'ni');
			disp(['bagger_par_singlerun::output saved to ' params.tempOutputFile]);
    
    case 'touchDecoderPopSingleFeature'
		  % load the files from decoderPopSingleFeature step & prepare "y" data
			%    which is normally calcium but in this case is prediction of touch
			%    relevant variables (see namesTouchDecodeY for list) by cells
			for i=1:length(namesTouchDecodedY)
			  fname = strrep(params.firstStepOutputFile, '%featureName%', namesTouchDecodedY{i});
				load(fname,'-mat');

				% pull out relevant variables and buildup your y_touchdec
			  oidx = strcmp(orig_names, namesTouchDecodedY{i});
	  		y_touchdec(i,:,:) = squeeze(resultsPopulation.population.x_predict_trial(1,:,:));
				clear resultsPopulation; % don't want this stickign around for down below ...
			end

			% some housekeeping
			names_y_touchdec = namesTouchDecodedY;
			type_vec_touchdec_y = zeros(1,length(names_y_touchdec));
			shiftCa = optionsTree.decoder.calciumShifts;
			flag = 0;

			% Check if 0 is not included
			if isempty(find(optionsTree.decoder.calciumShifts == 0))
				flag = 1;
			else
				shiftCa (find(shiftCa==0)) = [];
			end

      % shift setup
			for i=1:length(names_y_touchdec),
				[y_touchdec names_y_touchdec type_vec_touchdec_y ]  = ...
				  appendShifted (y_touchdec,names_y_touchdec,type_vec_touchdec_y,names_y_touchdec{i},shiftCa,0);
					% If shift 0 is not included it has to be removed
				if flag == 1
					[y_touchdec names_y_touchdec type_vec_touchdec_y ]  = ...
	  				removeVariable (y_touchdec,names_y_touchdec,type_vec_touchdec_y,names_y_touchdec{1});
				end
			end
	 
		  % weight is uniform
  		weight_touchdec = ones(size(y_touchdec,2)*size(y_touchdec,3),length(namesTouchDecodedX));
			N_names = length(namesTouchDecodedX);

			% 2) setup and run the decoder
	    %% Population decoding
			resultsPopulation = decoderRF_twoStages (x_touchdec,y_touchdec,type_vec_touchdec,namesTouchDecodedX, ...
			  names_y_touchdec,namesTouchDecodedY,namesTouchDecodedX,[],N_shifts_touchdec, ...
				shiftsPerFeatureTouchDec,optionsTree,weight_touchdec);    
			resultsPopulation.population = getPSTHDecoderMultipleGo (x_touchdec,namesTouchDecodedX,namesTouchDecodedX, ...
			  'trial_class','',optionsTree.minTrials,resultsPopulation.parameters.listFeatures,resultsPopulation.population);
				resultsPopulation.population    = getMetricsDecoder (x_touchdec,namesTouchDecodedX,namesTouchDecodedX, ...
			  'trial_class','',optionsTree.minTrials,resultsPopulation.parameters.listFeatures,resultsPopulation.population);   

	    for i=1:length(namesTouchDecodedX)
				resultsPopulation.metric.category(i) = categoryError (reshape(squeeze(x_touchdec(i,:,:))',[],1), ...
					resultsPopulation.population.x_predict(:,i));
		  end

			resultsPopulation.parameters.decoderFeature.all      = namesTouchDecodedX;
			resultsPopulation.parameters.decoderFeature.original = namesTouchDecodedX;
			resultsPopulation.parameters.decoderFeature.selected = namesTouchDecodedX;
			resultsPopulation.parameters.decoderFeature.shifts   = shiftsPerFeatureTouchDec;
			save(params.fileToSave,'resultsPopulation');
      
    case 'touchDecoderSingleCellSingleFeature'
		  % load the files from decoderSingleCellSingleFeature step & prepare "y" data
			%    which is normally calcium but in this case is prediction of touch
			%    relevant variables (see namesTouchDecodeY for list) by cells
			for i=1:length(namesTouchDecodedY)
			  fname = strrep(params.firstStepOutputFile, '%featureName%', namesTouchDecodedY{i});
				load(fname,'-mat');

        % take the relevant neuron
        results = results{params.neuronIdx};
        
        % pull out relevant variables and buildup your y_touchdec
			  oidx = strcmp(orig_names, namesTouchDecodedY{i});
	  		y_touchdec(i,:,:) = squeeze(results.singleNeuron.x_predict_trial(1,:,:));
				clear results; % don't want this stickign around for down below ...
			end

			% some housekeeping
			names_y_touchdec = namesTouchDecodedY;
			type_vec_touchdec_y = zeros(1,length(names_y_touchdec));
			shiftCa = optionsTree.decoder.calciumShifts;
			flag = 0;

			% Check if 0 is not included
			if isempty(find(optionsTree.decoder.calciumShifts == 0))
				flag = 1;
			else
				shiftCa (find(shiftCa==0)) = [];
			end

      % shift setup
			for i=1:length(names_y_touchdec),
				[y_touchdec names_y_touchdec type_vec_touchdec_y ]  = ...
				  appendShifted (y_touchdec,names_y_touchdec,type_vec_touchdec_y,names_y_touchdec{i},shiftCa,0);
					% If shift 0 is not included it has to be removed
				if flag == 1
					[y_touchdec names_y_touchdec type_vec_touchdec_y ]  = ...
	  				removeVariable (y_touchdec,names_y_touchdec,type_vec_touchdec_y,names_y_touchdec{1});
				end
			end
	 
		  % weight is uniform
  		weight_touchdec = ones(size(y_touchdec,2)*size(y_touchdec,3),length(namesTouchDecodedX));
			N_names = length(namesTouchDecodedX);

			% 2) setup and run the decoder
	    %% decoding
			resultsSingleCell = decoderRF_twoStages (x_touchdec,y_touchdec,type_vec_touchdec,namesTouchDecodedX, ...
			  names_y_touchdec,namesTouchDecodedY,namesTouchDecodedX,[],N_shifts_touchdec, ...
				shiftsPerFeatureTouchDec,optionsTree,weight_touchdec);    
			resultsSingleCell.population = getPSTHDecoderMultipleGo (x_touchdec,namesTouchDecodedX,namesTouchDecodedX, ...
			  'trial_class','',optionsTree.minTrials,resultsSingleCell.parameters.listFeatures,resultsSingleCell.population);
				resultsSingleCell.population = getMetricsDecoder (x_touchdec,namesTouchDecodedX,namesTouchDecodedX, ...
			  'trial_class','',optionsTree.minTrials,resultsSingleCell.parameters.listFeatures,resultsSingleCell.population);   

	    for i=1:length(namesTouchDecodedX)
				resultsSingleCell.metric.category(i) = categoryError (reshape(squeeze(x_touchdec(i,:,:))',[],1), ...
					resultsSingleCell.population.x_predict(:,i));
		  end

			resultsSingleCell.parameters.decoderFeature.all      = namesTouchDecodedX;
			resultsSingleCell.parameters.decoderFeature.original = namesTouchDecodedX;
			resultsSingleCell.parameters.decoderFeature.selected = namesTouchDecodedX;
			resultsSingleCell.parameters.decoderFeature.shifts   = shiftsPerFeatureTouchDec;
			save(params.fileToSave,'resultsSingleCell');
end
