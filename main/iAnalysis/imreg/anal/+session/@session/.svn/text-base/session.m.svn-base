%
% SP Aug 2010
%
% This defines a class for dealing with a single session -- includes collators
%  for ephus-whisker ; ephus-behav ; ephus-scim [i.e., all are ephus-centric].
%
% Contains the following fields:
%
%   caTSA - session.calciumTimeSeriesArray object that contains the fluorescnece
%           data
%   caTSAArray - optional structure with cell array if you want to have multiple 
%                calciumTimeSeriesArray objects.  If in play, it has fields:
%                caTSAArray.caTSA: cell array of caTSA objects
%                caTSAArray.validCaTrialIds: corresponding cell array with 
%                                            vectors
%                caTSAArray.curIdx: index of caTSA that is currently 'in play'
%
%   behavESA - contains behavioral event series
%
%   ephusTSA - contains ephus timeseries (usually severely downsampled)
%
%   trial - properties of individual trials stored in solo ifle
% 
%   whiskerCurvatureTSA - kappa measured along whisker
%   whiskerCurvatureChangeTSA - kappa normalized to baseline
%   whiskerAngleTSA - angle of whisker at polynomial intersect
%   whiskerBarCenterXYTSA - XY position of bar; 2 /whisker
%
%   whiskerBarContactESA - event series with contacts
%   whiskerBarContactClassifiedESA - event series with pro/re labeled contacts
%   whiskerBarInReachES - when bar was touchable
%
%   derivedDataTSA - properties such as pro/retraction times, whisker setpoint ,etc.
%                    used in classification
%   derivedDataESA - properties such as pro/retraction times, licks, bar moves
%                    used in classification
% 
% Feilds with identifying information
%  
%   mouseId - string representing mouse ID
%   dateStr - string representing date of the data acquistion
%   behavProtocolName - string with name of behavioral protocol used
%
% Generally constructed with the generateSession method, which uses the
%  dataSourceParams structure having the following fields:
%  
%    baseFileName: the base file name for where things are stored - FULL path 
%      This is where session object will be written to, along with subfiles.
%
%  Behavior stuff:
%
%    behavSoloFilePath: the .mat file generated by solo that contains behavioral data log
%    behavSoloParams: tells generateBehavioralDataStructures which states in the state
%                     matrix to grab and what to call them.  See that method for
%                     details.
%    trialBehavParams: tells generateBehavioralDataStructures what to store in 
%                      each trial's behavParams structure.
%    trialTypeParams: Allows you to define trial typing: trialType 
%                   (session.session.trialType) ; trialTypeStr
%                   (session.session.trialTypeStr) and trialTypeColor, all of 
%                   which are fields of this structure (note that if any of the
%                   3 trialType variables is present, all must be).  Also, you
%                   can pass a field trialTypingFunc, which is the *name* of 
%                   a function that should take the loaded solo .mat file
%                   as a parameter and return trialType.  Must be in your path.
%                   Specifically, eval([trialTypingFunc '(soloDat,t);']) is 
%                   called and this should return the trial type # of trial t 
%                   where soloDat = load(soloFilePath).
%
%  Ephus stuff:
%
%    ephusFilePath: where ephus files are ; timestamp, bitcode used for alignment
%    ephusFileWC: wildcard specifying subset of files to use
%    ephusChanIdent: identity of channels that you want pulled ; cell array of strings
%    ephusDownsample: will downsample by this factor (2 = use 1/2, 10:1/10 and so on)
%
%  Scanimage stuff:
%
%    Scanimage is gathered using the method 
%    session.calciumTimeSeriesArray.generateCalciumTimeSeriesArray. See its
%    documentation for details.
%
%    scimFilePath: where scanimage files are
%    scimFileWC: wildcard to apply within directory for files that are trials
%    roiArrayPath: where the roiArray object resides, defining the ROIs used for imaging
%
%    To do multiple roiArrays that are imaged "simultaneously" (i.e,. volume imaging),
%     use a cell array for each of the above.  If you have distinct regions that 
%     were imaged while volume imaging (column imaging), specify a cell array of
%     cell arrays for each of the above, where var{v}{f} corresponds to volume
%     v and plane f.
%
%    scimFileList: an alternative to above approach where an *explicit* file list
%                  is provided.  Volume/column imaging not supported.
%    scimFileTrial: if a scimFileList is provided, a trial # for each file can be
%                   explicitly given to skip auto trial # extraction from filename
%                   as well as subsequent alignment.  Must be in terms of trial 
%                   numbers in session.trial.id.  That is, scimFileList(x) will have
%                   trial # session.trial.id scimFileTrial(x).
%
%  Whisker-related stuff:
%
%    Whisker data is gathered using session.whiskerTrialArray.generateUsingParams;
%      see this for details on how data is compiled.
%
%    whiskerTrialArrayBaseFileName: where whiskerTrialArray object resides ; full name
%    whiskerFilePath: directories whisker tracking .mat files reside
%    whiskerFileWC: wildcard to apply therewithin ; if you are importing a 
%      whiskerTrialLiteArray, this should be the filename of that file
%    whiskerTrialIncrement: Additional increment added to whisker trial #
%      relative to the number specified in the filename -- in case, for
%      instance, the numbering starts with 0.  Can be negative as well. Note 
%      that this is relative *ephus* trial numbering.  Whisker trial number
%      is assumed to be in line with ephus.  This allows you to offset it.
%      So say that ephus trial 2 was whisker trial 1.  Then this would be 1.
%    whiskerVideoTimeOffsetInMs: how many ms after trial start does whisker video
%      start?  default 100.
%    whiskerTrialArrayParams: a structure of arguments passed to the method
%      session.whiskerTrialArray.generateUsingParams.  This is really the key 
%      to customizing whisker data so see it.
%
% Internal:
%
%   loading: set to 1 during load to avoid set method calls
% 
classdef session< handle
  % Properties
  properties 
	  %% --- data

    %% basic
		mouseId; % Id of the mouse
		dateStr; % When experiment was performed
		behavProtocolName; % name of behavioral protocol

		%% raw data
		caTSA; % caTimeSeriesArray with fluo data for all rois
		caTSAArray; % structure that contains multiple caTSA objects
		behavESA; % event series arrays for behavioral data
		ephusTSA; % timeSeriesArray object with (downsampled) ephus dat
 
    whiskerTag; % names of the whiskers -- TSA{w} and ESA{w} has name whiskerTag{w}

		whiskerCurvatureTSA; % whisker kappas
		whiskerCurvatureChangeTSA; % whisker delta kappas
		whiskerAngleTSA; % thetas

		whiskerBarCenterXYTSA; % position of the bar in X/Y
		whiskerBarInReachES; % times of bar-in-reach -- SIGNLE EVENT SERIES

		whiskerBarContactESA; % times of contacts
		whiskerBarContactClassifiedESA; % contacts classified pro/retract

		%% derived data
		derivedDataTSA;
		derivedDataESA;

    %% --- internal
		%% storage pointers
		baseFileName = ''; % where the data is stored (the session and subordinate files)
		loadFlag = [0 0 0 0 0 0 0 0]; % -1: don't load [used during breakup saves] ; 0: not loaded but load ; 1: loaded
		loadableVar = {'caTSA', 'caTSAArray', 'ephusTSA', 'whiskerCurvatureTSA', 'whiskerCurvatureChangeTSA', ...
		               'whiskerAngleTSA', 'derivedDataTSA', 'whiskerBarCenterXYTSA'}; 

		% tells you which steps were completed in generateSession
		stepCompleted; 

		% stores the dataSourceParams structure that allows you to restrict action by
		%  many of the submethods, mostly the generateXXX methods.  See top for detailed
		%  list of subfields & meanings.
		dataSourceParams; 

    % misc data describing parameters
		cellFeatures; % hash object with various features (e.g., touchIndex etc.)
		
	  %% misc
		ephusOriginalTrialBitcodes; % for EACH original ephus xsg file, the bitcode
		                           % this is used in whisker->ephus->behav alignment

    % all of these are the same size, and indexing MUST correspond(!)
		trial; % cell array of trial objects
		trialIds; % stores trial #s
		trialStartTimes; % stores start times for all trials ...$
		trialTypeMat; % boolean vectors, where trialTypeMat(trialType,trialIdx) is 1 if trial
		            % of id trialIds(trialIdx) has type trialType

	  % trial types -- typically defined from generateBehavioralDataStructures
	  trialType;
		trialTypeStr;
		trialTypeColor;

    % valid trials for various conditions
		validWhiskerTrialIds; % trialIds that have good whisker data -- see 
		                      % generateWhiskerDataStructures
		validCaTrialIds; % trialIds with good calcium data -- filtering based on 
		                 % motion and large luminance changes is doen by the 
										 % lib/evaluate_registered_imaging_data.m fucntion that
										 % is called by the imreg_session_stats processor.  This is
										 % used by calciumTimeSeriesAray.generateCalciumTimeSeriesArray.
										 % Thus, by the time session.generateCalciumTimeSeriesArray is 
										 % called, filtering is in a sense done.  This variable is
										 % in fact assigned in alignScanimageWithEphus.
		validBehavTrialIds; % trialIds with valid behavioral data -- for now = trialIds
		validEphusTrialIds; % trialIds w/ good ephus data
		validDerivedTrialIds; % trial Ids for which generateDerivedData worked
 
		validTrialIds; % contains indices of trials -- in terms of trial{x}/solo
		                   % that have data from all sources; most plotting and
											 % analysis is restricted to these.  As of now, only
											 % generateSession will populate this.							


    improperSave = 1; % notify user they are not saving with saveToFile
		loading; % for stopping set calls
    
    % DEPRECATED
    treeFeatureList;
    treeScoreMatrix;
    touchIndex;
    discrimIndex;

  end

  properties(Transient = true) % not saved to file
		guiData; % stores all the gui-related stuff
		         %  guiData.TSBrowser
  end

  % fixed
  properties (Constant = true)

		% corresponds to stepCompleted
		stepName = {'generateBaseData', 'generateEphusData', 'generateCalciumData', ...
		             'generateWhiskerData', 'generateDerivedData'};
  end

	% Methods -- public
  methods (Access = public)
	  %
	  % Constructor
		%
    function obj = session(newMouseId, newDateStr, newCaTSA, newBehavESA, newEphusTSA, ...
		                      newWhiskerTag, newWhiskerCurvatureTSA, newWhiskerCurvatureChangeTSA, ...
													newWhiskerAngleTSA, newWhiskerBarContactESA, newTrials) 

			obj.loading =0;

		  % just ident?
			if (nargin >= 2)
			  obj.mouseId = newMouseId;
				obj.dateStr = newDateStr;
			end
			% full monty
			if (nargin >= 6)
			  obj.caTSA = newCaTSA;
				obj.behavESA = newBehavESA;
				obj.ephusTSA = newEphusTSA;
				obj.whiskerTag = newWhiskerTag;
				obj.whiskerCurvatureTSA = newWhiskerCurvatureTSA;
				obj.whiskerCurvatureChangeTSA = newWhiskerCurvatureChangeTSA;
				obj.whiskerAngleTSA = newWhiskerAngleTSA;
				obj.whiskerBarContactESA = newWhiskerBarContactESA;
				obj.trials = newTrials;
			end

			% steps that have been worked on here 
		  obj.stepCompleted = zeros(1,length(session.session.stepName));

			% Instantiate pretinent hash objects
      obj.cellFeatures = hash();
		end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%% DATA IMPORTING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		% master method for session generation
    obj = sequentialSessionGenerator(obj, forceRedo)

		% method that will generate a timeSEriesArray object from the ephus data
	  obj = generateEphusTimeSeriesArray(obj, ephusFilePath, ephusFileWC, ephusDownsample)

		% method that will generate a calciumTimeSeriesArray object from scanimage data
	  obj = generateCalciumTimeSeriesArray(obj, regenIdx)

		% method that will generate a timeSEriesArray object from the ephus data ;
		%  populates behavESA, trials
	  obj = generateBehavioralDataStructures(obj, soloFilePath, behavSoloParams, trialBehavParams, trialTypeParams)

    % will generate whisker arrays
		obj = generateWhiskerDataStructures (obj)

		% will generate derived data
    obj = generateDerivedDataStructures(obj, params)

		% as the name implies ...
    obj = alignScanimageWithEphus(obj)

		% converts licklaser into an event series and puts it into behavESA
		obj = generateLicklaserES(obj)

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILITY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		% wrapper for eventSeries.deriveTimeSeriesByConv over specific trials
		ts = deriveTimeSeriesByConv(obj, es, kernel, trials)

		% wrapper for eventSeries.deriveRateTimeSeries over specific trials
		ts = deriveRateTimeSeries(obj, es, trials)

		% computes roi touch index
    obj = computeRoiTouchIndex(obj,  params)
    
		% computes discrimination for, e.g., cells by, e.g., ROC analysis
		discrim = computeDiscrim(obj, params)

    % returns an event series for a specified event sequence
    es = getSequentialWhiskerContactES (obj, sequence, sequenceMaxDt, burstDt)

    % returns event series array of various contact sequences
    sESA = s.getSequentialWhiskerContactESA(contacts, sequenceMaxDt, burstDt)

    % returns eventSeries with overlappign contancst
    es = getCoincidentWhiskerContactES (obj, contacts, coincidentDtMax)

		% returns a event series array of various contact combos
    cESA = getCoincidentWhiskerContactESA(obj, contacts, coincidentDtMax)

	 	% generates contact triggered images for all whiskers, updating roiArray
		obj = generateWhiskerContactTriggeredImages(obj, baselineTimeWindow, responseTimeWindow, saveToRoiFile)

    % goes thru various whiskers and aspects of their stimulus to determine what ROI cares about
    retParams = computeRoiWhiskerContactVariableImportance(obj, params)
 
    % uses ROC curves to decide prefered whisker and direction *with confidence intervals*
    retParams = s.computeWhiskerAndDirectionPreference(params)

		% comptues discrimination of a roi conditioned on balanced distributions of, e.g., force
    computeRoiConditionalDiscrimination(obj, params)
    
		% lets you pull the RF for a whisker contact/roi dff
		[st re params sTS rTS es rValMat] = getPeriWhiskerContactRF(obj, params)

		% tries to tease apart kappa, theta, and directional selectivity
		retParams = computeRoiPrefKappaThetaDir (obj, params)

		% gathers summary of whisking behavior
    wsData = getWhiskingSummaryData(obj)

		% computes contact properties for whiskerBarContactClassifiedESA
    generateContactPropertiesHashes(obj)

    % computes various cell featuers
		generateCellFeaturesHash(obj, params)

		% based on cell features, assigns class
    assignCellClass (obj, params)

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TREE BAGZ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
		% generates par files for daemon execution
		setupTreeBaggerPar(obj, rootParDir,  treeBaggerParams,  cellResponseTSA, stimulusFeatureTSA)

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PLOTTING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		% plots performance
		performanceStats = plotPerformance (obj, tOffset, progress, figHan)

		% plots whisking summary
    plotWhiskingSummary(obj, params)

		% plots time series as line
    plotTimeSeriesAsLine(obj, tsa, tsIdx, ESs, typesPlotted, trialsPlotted, axisBounds, plotAxes, showLeged)

		% plots time series as image
    plotTimeSeriesAsImage(obj, tsa, tsIdx, ESs, typesPlotted, sortByType, colorMap, ...
		   xAxisBounds, valueRange, plotAxes)

    % plot colored ROIs
    plotColorRois(obj,plotMode, trialTypes, trialIds, colorMap, colorBasisVec, colorBasisVecRange, axHandle, drawColorBar, fovIdx)

		% Wrapper for guiTSABrowser
		guiTSABrowser(obj)

		% DEPRECATED: GUI for timeseries plotting
		guiTSBrowser(obj, subFunction, subFunctionParams)

		% DEPRECATED: GUI for eventseries plotting in context of guiTSBrowser
		guiESControl(obj, subFunction, subFunctionParams)

    % DEPRECATED: GUI for plot control for TS Browser
    guiPlotSetupControl(obj, subFunction, subFunctionParams);

    % Plots a neuron's calcium RF in terms of delta kappa
    plotKappaRF (obj, whiskerIdx, roiId, params, plotRFParams, axHandle)

    % generic plotter for RF around event series
    plotPeriEventRF(obj, stimTSA, stimTSId, stimTimeWindow, stimMode, ...
                         respTSA, respTSId, respTimeWindow, respMode, ESA, ...
												 ESId, ESColor, trialEventNumber, xES,  xESTimeWindow, ...
												 excludeOthers, plotRFParams, axHandle, stimUseValueDuringEventOnly, respUseValueDuringEventOnly, ...
												 labeledESA, labeledESId, labeledESColor, labeledESOverlapWindow)

		% Plot bar graph with scores for various features for a ROI
    plotRoiScoreAcrossFeatures(obj, roiIds, whiskers, params)

		% Plot bar graph with touch index
    plotRoiTouchScoreAcrossWhiskers(obj, roiId, features, plotParams)

		% plot roi touches
    plotRoiTouchIndex (obj, params, computeRTIParams)

		% 2D RF plotter for 2 stimuli + 1 response dim
    plotMultiStimRF(obj, params1, params2, params)

    % Plots simple touch triggered response for a cell
    plotTouchTriggeredAverage(obj, params)

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MISC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    function lightObj = lightCopy(obj)
			% make an empty object
			lightObj = session.session();

      % anything that is NOT loadableVar should be saved ...
			varList = fieldnames(obj);
			for v=1:length(varList)
        % save only loadable vars
			  if (sum(strcmp(varList{v}, obj.loadableVar)) == 0)
          % ensure it is not constant, because we don't need to copy those
          fp = findprop(obj, varList{v});
          if (~fp.Constant)
				    eval(['lightObj.' varList{v} ' = obj.' varList{v} ';']);
          end
				end
			end
 
      % reset loadFlag
			lightObj.loadFlag = -1+0*obj.loadFlag;
    end

		function obj = saveToFile(obj, baseFileName)
      % file name passed?
			if (nargin > 1)
			  obj.baseFileName = baseFileName;
			end
		  
			% make a copy -- this is what you will actually save(!)
			s = obj.lightCopy();

		  % save loadable variables - caTSA, ephusTSA, etc. - to individual files
			for v=1:length(obj.loadableVar)
				obj.saveLoadOnGet(obj.loadableVar{v});
			end

			% save call
			obj.improperSave = 0;
			save (obj.baseFileName, 's');

			% --- supplement -- caTSA, caTSAArray
			if (isstruct(obj.caTSAArray) && isfield(obj.caTSAArray, 'caTSA') && isobject(obj.caTSAArray.caTSA{1}))
			  disp('saveToFile not implemented with caTSAArray ; disregard warnings above');
				obj.caTSAArray.curIdx = 0; % ensure it is set to 0!
%			  for c=1:length(obj.caTSAArray)
%				  obj.caTSAArray.caTSA{c}.saveToFile();
%				end
			elseif (isobject(obj.caTSA))
			  obj.caTSA.saveToFile();
      end
		end

    %
		% you should not use this!
		%
		function obj = saveobj(a)
		  if (a.improperSave)
				disp('session.save::you should call saveToFile to save, not save!!');
			end
			obj = a;
		end

    %
		% save the loadOnGet stuff
		%
		function saveLoadOnGet(obj, varName)
			subFile = strrep(obj.baseFileName, '.mat', ['.' varName '.mat']);
			if (strcmp(subFile, obj.baseFileName)) % same? then append varName bc no extension
				subFile = [subFile '.' varName '.mat'];
			end
			if (exist(subFile) == 2) % if it exists, we check for save
				idx = find(strcmp(obj.loadableVar ,varName));
				if (obj.loadFlag(idx))
				  saveVar = eval(['obj.' varName]) ; save(subFile, 'saveVar');
				end
			else % write, since file non-existent
			  saveVar = eval(['obj.' varName]) ; save(subFile, 'saveVar');
			end
		end

    % 
		% loads a file-stored variable
		% 
		function value = loadOnGet(obj, varName)
			value = [];

		  subFile = strrep(obj.baseFileName, '.mat', ['.' varName '.mat']);
			if (strcmp(subFile, obj.baseFileName)) % same? then append varName bc no extension
			  subFile = [subFile '.' varName '.mat'];
			end
			idx = find(strcmp(obj.loadableVar ,varName));
			fullPathSubFile = subFile;

      % default is to use PWD
			if (exist(subFile(max(find(subFile == filesep))+1:end)) ~= 2) % try same but what if from different OS?
			  dfilesep = '\'; 
				if(filesep == dfilesep) ; dfilesep = '/'; end
				subFile = subFile(max(find(subFile == dfilesep))+1:end);
				subFile = [pwd filesep subFile];
			else
				subFile = subFile(max(find(subFile == filesep))+1:end);
				subFile = [pwd filesep subFile];
			end

			% otherwise try fullpath ...
			if (exist(subFile) ~= 2) 
			  subFile = fullPathSubFile;
			end

		  if (exist(subFile) == 2 & obj.loadFlag(idx) == 0)
	   		disp(['session.loadOnGet::loading ' subFile]);
			  load(subFile);
				if (exist('saveVar','var'))
					value = saveVar;
				elseif (exist('o','var'))
					value = o;
				end
        obj.loadFlag(idx) = 1;
			end
		end

		% updates trialTypeMat (type,idx)
		function obj = updateTrialTypeMat(obj)
      obj.trialTypeMat = zeros(length(obj.trialType), length(obj.trialIds));
		  for t=1:length(obj.trial)
			  memIdx = find(ismember(obj.trialType,obj.trial{t}.typeIds));
				obj.trialTypeMat(memIdx,t) = 1;
			end
		end

		% returns trialIds based on type match
    trialIds = getTrialIdByTypes(obj, types, subsetTrialIds)

		% deletes set of calcium trials
		function obj = deleteCalciumTrials(obj, trialIds)
		  obj.caTSA.deleteTrials(trialIds);

			obj.validCaTrialIds = setdiff(obj.validCaTrialIds,trialIds);
			obj.validTrialIds = setdiff(obj.validTrialIds,trialIds);
			if (isobject(obj.derivedDataTSA)) % regenerate derived data
			  obj.generateDerivedDataStructures();
      end
		end

		% assigns caTSAArray, when this is in use
		function obj = useCaTSAArray(obj, newIdx)
		  if (~isstruct(obj.caTSAArray))
			  disp('session.session.useCaTSAArray::must have caTSAArray instantiated.');
			else
			  if (length(newIdx) == 0) % de-assign caTSA altogether
    		  obj.caTSAArray.curIdx = 0;
					obj.caTSA = [];
					obj.validCaTrialIds = [];
					obj.validTrialIds = obj.validBehavTrialIds;
					if (length(obj.validWhiskerTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validWhiskerTrialIds); end
					if (length(obj.validEphusTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validEphusTrialIds); end
					if (length(obj.validDerivedTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validDerivedTrialIds); end
				elseif (newIdx ~= obj.caTSAArray.curIdx & newIdx > 0 & newIdx <= length(obj.caTSAArray.caTSA)) % valid id then assign it
					% gui? delete this first ...
					redrawGui = 0;
					if (isstruct(obj.guiData) && isfield(obj.guiData, 'TSABrowser') && ...
					    strcmp(class(obj.guiData.TSABrowser), 'session.guiTSABrowser') && ...
							ishandle(obj.guiData.TSABrowser.figH))
					  % delete current and record position
					  cPos = get(obj.guiData.TSABrowser.figH, 'Position');
					  if(ishandle(obj.guiData.TSABrowser.figH)) ; close(obj.guiData.TSABrowser.figH); end
					  if(ishandle(obj.guiData.TSABrowser.ESListFigH)) ; close(obj.guiData.TSABrowser.ESListFigH); end
					  if(ishandle(obj.guiData.TSABrowser.lineFigH)) ; close(obj.guiData.TSABrowser.lineFigH); end
					  if(ishandle(obj.guiData.TSABrowser.trialPlotH)) ; close(obj.guiData.TSABrowser.trialPlotH); end
						for f=1:obj.caTSA.numFOVs
							if (length(obj.caTSA.roiArray{f}.guiHandles) >= 3 && ishandle(obj.caTSA.roiArray{f}.guiHandles(3)))
								delete (obj.caTSA.roiArray{f}.guiHandles(3));
							end
							if (length(obj.caTSA.roiArray{f}.guiHandles) >= 0)
								obj.caTSA.roiArray{f}.guiHandles = [];
							end
						end
					  obj.guiData = [];
						redrawGui =1;
          end

					% now handle actual objects
    		  obj.caTSAArray.curIdx = newIdx;
					obj.caTSA = obj.caTSAArray.caTSA{newIdx};
					obj.validCaTrialIds = obj.caTSAArray.validCaTrialIds{newIdx};
					obj.validTrialIds = intersect(obj.validBehavTrialIds, obj.validCaTrialIds);
					if (length(obj.validWhiskerTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validWhiskerTrialIds); end
					if (length(obj.validEphusTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validEphusTrialIds); end
					if (length(obj.validDerivedTrialIds) > 0) ; obj.validTrialIds = intersect(obj.validTrialIds, obj.validDerivedTrialIds); end

					% and finally recreate gui
					if (redrawGui)
						% instantiate new and create it..
						obj.guiTSABrowser();
					  set(obj.guiData.TSABrowser.figH, 'Position', cPos);
				  end
				elseif (newIdx < 0 | newIdx > length(obj.caTSAArray.caTSA)) % valid id then assign it
			    disp('session.session.useCaTSAArray::invalid caTSAArray number.');
				end
			end
		end

		% === static method wrappers
		function plotEventTriggeredAverage(varargin)
		  plotEventTriggeredAverageS(varargin{2:end});
		end
	end

	methods (Static) % static methods 

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% UTILITY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		% Generates a session object using specified behavioral, ephus, scanimage,
		%  and whisker data.  See header for the parts of dataSourceParams.
		s = generateSession(dataSourceParams)

		% Generic receptive field plotter
		plotRF(stimulus, response, plotMethod, plotParams, color, axHandle, axRange);

    % Generic bar plotter for response across, e.g., features
    plotBarRF(barValues, barLabels, plotParams)

		% Plots an event-triggered average
    [mumax semumax medmax iqrmedmax nev] = plotEventTriggeredAverageS(obj, tsa, tsIdx, es, ...
		   eventNum, axisBounds, plotAxes, col, timeWindow, esExclude, esExcludeTimeWindow, ...
			 showN, avgType, allowOverlap)

		% Correlation betwen two timeseries plotter
		plotTSCrossCorrelationS(tsaA, tsAId, tsaB, tsBId, offsets, ax, corrType, color);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTERNAL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% loads pertinent information from an ephus XSG file
    ephusFile = getEphusFile(ephFname, channelId)

		% this is called on load
	  function obj = loadobj(a) 
		  a.loading = 1;
		  ns = session.session(); % create new session object in case you change loadableVar (otherwise loaded one will be used)
			a.loadFlag = 0*(1:length(ns.loadableVar)); % set it to 0 so it gets loaded ; it is saved as -1
			a.loadableVar = ns.loadableVar;
		  obj = a;
			obj.loading =0 ;
		end
	end

  % Methods -- set/get/basic variable manipulation stuff
	methods 
	  % trials -- you should update trialIds on assignment , trialTypes(type,idx)
		function obj = set.trial (obj, newTrial)
		  obj.trial = newTrial;
			obj.trialIds = [];

      % loop thrgouh trials
			for t=1:length(newTrial)
			  obj.trialIds(t) = newTrial{t}.id;
			end

			% trialTypeMat
			obj.updateTrialTypeMat();
		end

		% for loadOnGet support
		function value = get.whiskerCurvatureTSA (obj)
		  if (~isobject(obj.whiskerCurvatureTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'whiskerCurvatureTSA');
				obj.whiskerCurvatureTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'whiskerCurvatureTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.whiskerCurvatureTSA;
		end
		function obj = set.whiskerCurvatureTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'whiskerCurvatureTSA'));
          obj.loadFlag(idx) = 1;
					obj.whiskerCurvatureTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.whiskerCurvatureTSA::must be a timeSeriesArray or blank.');
        end
			end
    end
    
		% for loadOnGet support
		function value = get.whiskerCurvatureChangeTSA (obj)
		  if (~isobject(obj.whiskerCurvatureChangeTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'whiskerCurvatureChangeTSA');
				obj.whiskerCurvatureChangeTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'whiskerCurvatureChangeTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.whiskerCurvatureChangeTSA;
		end
		function obj = set.whiskerCurvatureChangeTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'whiskerCurvatureChangeTSA'));
          obj.loadFlag(idx) = 1;
					obj.whiskerCurvatureChangeTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.whiskerCurvatureChangeTSA::must be a timeSeriesArray or blank.');
        end
			end
    end

		% for loadOnGet support
		function value = get.whiskerAngleTSA (obj)
		  if (~isobject(obj.whiskerAngleTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'whiskerAngleTSA');
				obj.whiskerAngleTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'whiskerAngleTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.whiskerAngleTSA;
		end
		function obj = set.whiskerAngleTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'whiskerAngleTSA'));
          obj.loadFlag(idx) = 1;
					obj.whiskerAngleTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.whiskerAngleTSA::must be a timeSeriesArray or blank.');
        end
			end
    end

		% for loadOnGet support
		function value = get.derivedDataTSA (obj)
		  if (~isobject(obj.derivedDataTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'derivedDataTSA');
				obj.derivedDataTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'derivedDataTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.derivedDataTSA;
		end
		function obj = set.derivedDataTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'derivedDataTSA'));
          obj.loadFlag(idx) = 1;
					obj.derivedDataTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.derivedDataTSA::must be a timeSeriesArray or blank.');
        end
			end
    end


		% for loadOnGet support
		function value = get.ephusTSA (obj)
		  if (~isobject(obj.ephusTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'ephusTSA');
				obj.ephusTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'ephusTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.ephusTSA;
		end
		function obj = set.ephusTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'ephusTSA'));
          obj.loadFlag(idx) = 1;
					obj.ephusTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.ephusTSA::must be a timeSeriesArray or blank.');
        end
			end
    end


		% for loadOnGet support
		function value = get.caTSA (obj)
		  if (~isobject(obj.caTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'caTSA');
				obj.caTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'caTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.caTSA;
		end
		function obj = set.caTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.calciumTimeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'caTSA'));
          obj.loadFlag(idx) = 1;
					obj.caTSA = value;
        elseif (length(value) > 0) % allow blanking but that's it
          disp('session.set.caTSA::must be a calciumTimeSeriesArray or blank.');
        end
			end
    end

		% for loadOnGet support
		function value = get.caTSAArray (obj)
		  if (~isstruct(obj.caTSAArray)) % not structure? try to load it 
		    value = loadOnGet(obj, 'caTSAArray');
				obj.caTSAArray = value;
			else
				idx = find(strcmp(obj.loadableVar ,'caTSAArray'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.caTSAArray;
		end
		function obj = set.caTSAArray (obj,value)
      if (~obj.loading)
        if (isstruct(value))
          idx = find(strcmp(obj.loadableVar ,'caTSAArray'));
          obj.loadFlag(idx) = 1;
					obj.caTSAArray = value;
        elseif (length(value) > 0) % blanking allowed but that's it
          disp('session.set.caTSAArray::must be a struct or blank.');
        end
			end
    end

		% for loadOnGet support
		function value = get.whiskerBarCenterXYTSA (obj)
		  if (~isobject(obj.whiskerBarCenterXYTSA)) % not object? try to load it 
		    value = loadOnGet(obj, 'whiskerBarCenterXYTSA');
				obj.whiskerBarCenterXYTSA = value;
			else
				idx = find(strcmp(obj.loadableVar ,'whiskerBarCenterXYTSA'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.whiskerBarCenterXYTSA;
		end
		function obj = set.whiskerBarCenterXYTSA (obj,value)
      if (~obj.loading)
        if (isobject(value) && strcmp(class(value), 'session.timeSeriesArray')) 
          idx = find(strcmp(obj.loadableVar ,'whiskerBarCenterXYTSA'));
          obj.loadFlag(idx) = 1;
					obj.whiskerBarCenterXYTSA = value;
        else
          disp('session.set.whiskerBarCenterXYTSA::must be a timeSeriesArray.');
        end
			end
    end

    % baseFileName -- relativbe root data path
    function obj = set.baseFileName(obj, newBaseFileName)
		  obj.baseFileName = init_root_data_path(newBaseFileName);
    end

    % returns the baseFileName -- WITH global path !
    function value = get.baseFileName(obj)
      value = assign_root_data_path(obj.baseFileName);
    end

    % -- make sure all fields are present, but blank if not assigned ; also, do assign_root_data_path on pertinents
		function value = get.dataSourceParams(obj)
		  if (~isfield(obj.dataSourceParams, 'baseFileName')) ; obj.dataSourceParams.baseFileName = []; end

		  if (~isfield(obj.dataSourceParams, 'behavSoloFilePath')) ; obj.dataSourceParams.behavSoloFilePath = []; end

		  if (~isfield(obj.dataSourceParams, 'ephusFilePath')) ; obj.dataSourceParams.ephusFilePath = []; end
		  if (~isfield(obj.dataSourceParams, 'ephusFileWC')) ; obj.dataSourceParams.ephusFileWC = []; end
			if (~isfield(obj.dataSourceParams, 'ephusChanIdent')) ; obj.dataSourceParams.ephusChanIdent = []; end
		  if (~isfield(obj.dataSourceParams, 'ephusDownsample')) ; obj.dataSourceParams.ephusDownsample = []; end

		  if (~isfield(obj.dataSourceParams, 'scimFilePath')) ; obj.dataSourceParams.scimFilePath = []; end
		  if (~isfield(obj.dataSourceParams, 'scimFileWC')) ; obj.dataSourceParams.scimFileWC = []; end
		  if (~isfield(obj.dataSourceParams, 'scimFileList')) ; obj.dataSourceParams.scimFileList = []; end
		  if (~isfield(obj.dataSourceParams, 'scimFileTrial')) ; obj.dataSourceParams.scimFileTrial = []; end
		  if (~isfield(obj.dataSourceParams, 'roiArrayPath')) ; obj.dataSourceParams.roiArrayPath = []; end
		  if (~isfield(obj.dataSourceParams, 'scimIgnoreSessionStats')) ; obj.dataSourceParams.scimIgnoreSessionStats = 0; end

		  if (~isfield(obj.dataSourceParams, 'whiskerFilePath')) ; obj.dataSourceParams.whiskerFilePath = []; end
		  if (~isfield(obj.dataSourceParams, 'whiskerFileWC')) ; obj.dataSourceParams.whiskerFileWC = []; end
		  if (~isfield(obj.dataSourceParams, 'whiskerVideoTimeOffsetInMs')) ; obj.dataSourceParams.whiskerVideoTimeOffsetInMs = 100; end
		  if (~isfield(obj.dataSourceParams, 'whiskerTrialIncrement')) ; obj.dataSourceParams.whiskerTrialIncrement = 0; end
		  if (~isfield(obj.dataSourceParams, 'whiskerTrialArrayParams')) ; obj.dataSourceParams.whiskerTrialArrayParams = []; end
		  if (~isfield(obj.dataSourceParams, 'whiskerTrialArrayBaseFileName')) ; obj.dataSourceParams.whiskerTrialArrayBaseFileName = []; end

  
			value = obj.dataSourceParams;
		end

 
	  % -- ID ; nothing for now
	  %function obj = set.id (obj, newId)
		%  obj.id = newId;
		%end
	  %function value = get.id (obj)
		%  value = obj.id;
		%end
  end


end
