%
% SP Nov 2011
%
% This will populate session.cellFeaturesHash.  It uses s.derivedDataTSA and
%  s.derivedDataESA, which are generated by s.generateDerivedDataStructures to
%  accomplish this.  
%
%  For timeSeries in derivedDataTSA, it will compute the correlation with all
%  calcium time series objects, and, given a range of temporal shifts, return 
%  the max.
%
%  For eventSeries in derivedDataESA, it will compute ideal observer area under
%  ROC using caDffTSA, as well as conditional probability product with calcium
%  events (that is, P(E|Ca)*P(Ca|E) where E are events in your eventSeries and
%  Ca area calcium 'events'.  ROC area-under-curve (AUC) sees if you can use
%  the calcium transient around the event to distinguish from randomly drawn
%  calcium events.
%
% [TREE?]
% 
% USAGE:
% 
%   s.generateCellFeaturesHash(params)
%
% PARAMS: params is a structure with following fields ; all are optional.
%
%   rootTag: this string is added to each field name in the cellFeatures hash.
%             If this is 'dff.', then ALL above fields will be, e.g., 
%             'dff.lickCorr'.
%   caDffTSA: string that is eval'd [obj '.' caDffTSA].  Default is to use 
%             caTSA.caPeakTimeSeriesArray.
%
function generateCellFeaturesHash(obj, params)

  %% --- process passed vars
	rootTag = '';
	caDffTSA = obj.caTSA.caPeakTimeSeriesArray.copy();
	if (nargin >= 2 && isstruct(params))
	  if(isfield(params, 'rootTag')) ; rootTag = params.rootTag; end
		if (isfield(params, 'caDffTSA')) ; caDffTSA = eval(['obj.' params.caDffTSA '.copy();']); end
	end

	%% --- variable definitions non-passed vars
	
	caBurstDt = 1000; % uses this burst timing to count bursts once only

	ppCaWindow = [-2 0]; % for pprod, in seconds, by how much ca events are extended
	ppEvWindow = [0 2]; % window by which events are expanded from derivedDataESA
	ppNumCaEvMin = 10; % 10 bursts @ least ...

	aucEvWindow = [0 2]; % how much Ca data to use for AUC computations
	aucNumCaEvMin = 10; % at least 10 bursts

  corrNumCaEvMin = 10; % at least 10 bursts
  corrOffs = -5:5; % correlations considered, in terms of vector indexing, NOT TIME

  %% --- set things up

	% setup hash
	if (~isobject(obj.cellFeatures))
	  obj.cellFeatures= hash();
	end

	% cleanup very small events
	caDffTSA.valueMatrix(find(abs(caDffTSA.valueMatrix < .01))) = 0;

	% enforce validTrialIds -- nan the rest
  val = find(ismember(caDffTSA.trialIndices, obj.validTrialIds));
	inval = setdiff(1:length(caDffTSA.time), val);
	caDffTSA.valueMatrix(:,inval) = nan;

  % verify that generateContactPropertiesHashes was run
	for e=1:length(obj.whiskerBarContactESA)
	  if (length(obj.whiskerBarContactESA.esa{e}.eventPropertiesHash) < 1)
		  disp('generateCellFeaturesHash::must first run generateContactPropertiesHashes.');
			return;
		end
	end
	for e=1:length(obj.whiskerBarContactClassifiedESA)
	  if (length(obj.whiskerBarContactClassifiedESA.esa{e}.eventPropertiesHash) < 1)
		  disp('generateCellFeaturesHash::must first run generateContactPropertiesHashes.');
			return;
		end
	end

  % burst-based calcium eventseries
  nCaBursts = zeros(1,length(obj.caTSA.caPeakEventSeriesArray));
	for r=1:length(obj.caTSA.caPeakEventSeriesArray)
	  caBursts{r} = obj.caTSA.caPeakEventSeriesArray.esa{r}.getBurstTimes(caBurstDt);
		nCaBursts(r) = length(caBursts{r});
	end

  %% --- TSA loop
	for t=1:length(obj.derivedDataTSA)
	  ts = obj.derivedDataTSA.getTimeSeriesByIdx(t);

		% build tag
		tag = ts.idStr;
		spidx = find(tag == ' ');
		for i=1:length(spidx) ; if (spidx + 1 <= length(tag)) ; tag(spidx+1) = upper(tag(spidx+1)); end ; end
		tag = strrep(tag, ' ', '');

	  % Corr
    try
      thisCorr = computeCorr (caDffTSA, ts, [], corrOffs, corrNumCaEvMin, nCaBursts);
		catch me
      thisCorr = [];
			disp(['generateCellFeaturesHash::computCorr error message: ']); 
      disp(' '); disp(getReport(me, 'extended')); disp(' ');
		end
		% storr 
		obj.cellFeatures.setOrAdd([rootTag tag 'Corr'],thisCorr);
  end

  %% --- ESA loop
	for e=1:length(obj.derivedDataESA)
	  es = obj.derivedDataESA.esa{e};

		% build tag
		tag = es.idStr;
		spidx = find(tag == ' ');
		for i=1:length(spidx) ; if (spidx + 1 <= length(tag)) ; tag(spidx+1) = upper(tag(spidx+1)); end ; end
		tag = strrep(tag, ' ', '');

	  % AUC
    try
      thisAUC = computeAUC(caDffTSA, caDffTSA, es, aucEvWindow, nCaBursts, aucNumCaEvMin);
		catch me
      thisAUC = [];
			disp(['generateCellFeaturesHash::computAUC error message: ']); 
      disp(' '); disp(getReport(me, 'extended')); disp(' ');
		end

		% PProd
    try
      thisPProd = computePProd(caDffTSA, caBursts, es, ppCaWindow, ppEvWindow, ppNumCaEvMin, nCaBursts);
		catch me
      thisPProd = [];
			disp(['generateCellFeaturesHash::computPProd error message: ']); 
      disp(' '); disp(getReport(me, 'extended')); disp(' ');
		end

		% store both
		obj.cellFeatures.setOrAdd([rootTag tag 'AUC'],thisAUC);
		obj.cellFeatures.setOrAdd([rootTag tag 'PProd'],thisPProd);
  end


%
% corr wrapper -- computes maximal correlation using different time shifts
% 
function retcorr = computeCorr (caDffTSA, xTS, excludeTS, corrOffs, numCaEvMin, nEv)
	disp(['generateCellFeaturesHash::computing correlations for ' xTS.idStr]);

  % make xTS compliant with caDffTSA
  caTS = caDffTSA.getTimeSeriesByIdx(1);
  
  % resample?
  if (xTS.length() ~= caTS.length() || sum(xTS.time == caTS.time) < length(caTS.time))
    xTS.reSample(100, [], caTS.time);
  end

	if (length(excludeTS) > 0)
	  if (isobject(excludeTS))
			xTS.value = xTS.value .* excludeTS.value;
		elseif (iscell(excludeTS))
		  for e=1:length(excludeTS)
			  xTS.value = xTS.value .* excludeTS{e}.value;
			end
		end
	end

  % loop
	retcorr = nan*ones(1,length(caDffTSA.ids));
	disp('000000');
	for r=1:length(caDffTSA.ids)
	  if (nEv(r) >= numCaEvMin)
			dffTS = caDffTSA.getTimeSeriesByIdx(r);
			retcorr(r) = max(session.timeSeries.computeCorrelationS(dffTS, xTS, corrOffs));
			disp([8 8 8 8 8 8 8 sprintf('%06d', r)]);
		end
	end


%
% pprod wrapper -- computes P(ca|x).*P(x|ca) for all ROIs
%
function pprod = computePProd (caDffTSA, caES, xES, ppCaWindow, ppXWindow, ppNumCaEvMin, nEv, excludeCaES, excludeCaWindow)
  if (nargin < 8) ; excludeCaES = []; excludeCaWindow = []; end
	if (isobject(xES)) ; disp(['generateCellFeaturesHash::computing pprod for ' xES.idStr]); end

	% P(ca|x)
	PcaGx = session.eventSeries.getConditionalProbability(caDffTSA, caES, ppCaWindow, excludeCaES, ...
		excludeCaWindow, xES , [], [], [], [], 0, 0);

	% P(x|ca)
	PxGca = 0*nEv;
	disp('000000');
	for r=1:length(caDffTSA.ids)
		if(nEv(r) >= ppNumCaEvMin) % dont waste time
			PxGca(r) = session.eventSeries.getConditionalProbability(caDffTSA, xES, ppXWindow, [],  ...
				[], caES{r}, [], excludeCaES, excludeCaWindow, [], 0, 0);
		end
		disp([8 8 8 8 8 8 8 sprintf('%06d', r)]);
	end
	pprod = PxGca.*PcaGx;

%
% AUC wrapper -- computes AUC of distro around eventSeries xES vs random (NOT 
%   including xES)
%
function auc = computeAUC (caDffTSA, caDffTSANoise, xES, aucXWindow, nEv, aucNumCaEvMin, excludeES, excludeESWindow)
    if (nargin < 7) ; excludeES = [] ; excludeESWindow = [];  end
    auc = nan*nEv;
  	if (isobject(xES)) ; disp(['generateCellFeaturesHash::computing AUC for ' xES.idStr]); end

		% build indexes for xES based on first caDffTSA -- that is, which indices will
		%  we used for peri-event (xES) and which for random
		caTS = caDffTSA.getTimeSeriesByIdx(1);
		[dataMat xTimeMat idxMat plotTimeVec] = caTS.getValuesAroundEvents(xES, aucXWindow, 2 , 0, excludeES, excludeESWindow);
		valIdxMat = find(~isnan(idxMat) & ~isnan(dataMat));

		% now build random data vector from NON contact epoch
		caTSNoise = caDffTSANoise.getTimeSeriesByIdx(1);
		timeVec = caTSNoise.time;
		badIdx = find(ismember(timeVec, reshape(xTimeMat,[],1)));
		timeVec(badIdx) = nan;
		ti = find(~isnan(timeVec));
		rp = randperm(length(ti));
		rp = rp(1:min(length(ti),100)); % get same size, but at least 100 time points -- this is to make it faster
		randTimes = timeVec(ti(rp));
		[randDataMat timeMat randIdxMat plotTimeVec] = caTSNoise.getValuesAroundEvents(randTimes, aucXWindow, 2 , 0);
		valRandIdxMat = find(~isnan(randIdxMat) & ~isnan(randDataMat) & ~ismember(randIdxMat,badIdx));

		% and loop, computing AUC
		disp ('000000');
		for r=find(nEv >= aucNumCaEvMin) % only do active ROIs
			disp([8 8 8 8 8 8 8 sprintf('%06d',r)]);
			valvec = caDffTSA.valueMatrix(r,:);
			valvecnoise = caDffTSANoise.valueMatrix(r,:);
			
			dataMat = nan*idxMat;
			dataMat(valIdxMat) = valvec(idxMat(valIdxMat));
			
			randMat = nan*randIdxMat;
			randMat(valRandIdxMat) = valvecnoise(randIdxMat(valRandIdxMat));

			% AUC from distance to mean (nicolelis uses this)
			while(size(randMat,2) < size(dataMat,2)) ; dataMat = dataMat(:,1:end-1) ; end
			fullMat = [dataMat ; randMat];
			idxA = 1:size(dataMat,1);
			idxB = size(dataMat,1)+1:size(dataMat,1)+size(randMat,1);
      if (length(idxA) > 1 & length(idxB) > 1)
        [DVa DVb] = nicolelis_distance(fullMat, idxA, idxB);
        auc(r) = roc_area_from_distro(DVa, DVb);
      end
	
			% AUC off distro alone
%			auc(r) = roc_area_from_distro(reshape(dataMat,[],1)',reshape(randMat,[],1)');
		end

		% flip (i.e., ensure auc el [0.5 1])
		ni = find(auc < 0.5);
		auc(ni) = 1-auc(ni);


%
% given a touchES, returns angle-restricted touch ESs
%
function restrictedTouchESs = getAngleRestrictedTouchESs (touchES, angularRanges, paramUsed)
  angleVals = touchES.eventPropertiesHash.get(paramUsed);
  
  for a=1:size(angularRanges,1)
	  ar = angularRanges(a,:);
    valIdx = find(angleVals > ar(1) & angleVals <= ar(2));

    restrictedTouchESs{a} = touchES.restrictedCopy(touchES.eventTimes(valIdx));
	end


