%
% SP June 2010
%
% This defines a class for dealing with arrays of calcium timeseries data.
%  This class basically has all the key functionality for calcium transient
%  processing, handling etc.  At the core is the object itself, which
%  is a timeSeriesArray with the RAW fluorescence, and then the timeSeriesArray
%  dffTimeSEriesArray which has the delta-f-over-f, and the calciumEventSeriesA
%  caPeakEventSeriesArray which stores the "events".
%
%  ROIs are stored in a roiArray object of class roi.roiArray.
%
%  This is a subclass of session.timeSeriesArray.
%
% CONSTRUCTOR:
%
%  session.calciumTimeSeriesArray(tsaCellArray, newTrialIndices, newRoiArray, skipSort)
%
% PARAMS:
%
%  tsaCellArray: from which all data is taken to build the TSA - a cell array of
%    timeSEries objects.  The time vector must be same for all.
%  newTrialIndices: the trialIndices vector telling trial # for each time point
%  newRoiArray: the roiArray object 
%  skipSort: if you want to assign other stuff and sortByTime LATER, set to 1 - 
%    this is very important as the TSA must be temporally sorted
%
%  Generally you should use the static generation method, 
%    session.calciumTimeSeriesArray.generateCalciumTimeSeriesArray
%
% FIELDS (beyond session.timeSeriesArray)
%  	  
%   numFOVs: how many fields-of-view?  
%   roiFOVidx: index of roiArray object // FOV that this roi is part of -- that
%              is, for roi with id caTSA.ids(x), it belongs in 
%              caTSA.roiArray{roiFOVidx(x)}
%   roiArray: cell array of roiArray objects which stores position of ROIs for
%             a given FOV.  Note that roi IDs must not be the same across FOVs;
%             use the roiIDRange variable in roiArray to ensure this.
%   originalRoiArray: copies of roiArrays made on load/instantiation so that you
%                     can track roi changes
%
%		activeRoiIds: vector with list of IDs of ROIs that are considered active 
%   roiActivityStatsHash: various statistics generated by getRoiActivityStatistics,
%                         as well as list of active, hyperactive, and inactive
%		activityFreeImage: image from epoch with NO activity (based on events) 
%                      cell array with 1/FOV.
%
%	  triggerOffsetForTrialInMS: same length as time, trialIndices.  For each
%		                           data point, how many MS AFTER start of this
%															 trial did the trigger arrive in?  For now
%															 this is derived from scanimage and used to
%															 recalibrate time; in the future, this will be
%															 refined based on Y position.  This is used by 
%															 session.  The time stamps returned by
%															 generateCalciumTimeSeriesArray incorporate
%															 this already.
%
%		dffTimeSeriesArray: timeSeriesArray object but for dFF data
%		caPeakEventSeriesArray: calciumEventSeriesArray object with peaks
%		caPeakTimeSeriesArray: timeSeriesArray where all values are 0 except the 
%                          actual Ca event (i.e., no exponential decay)
%		eventBasedDffTimeSeriesArray: timeSeries array for dFF estimated from events
%
%		antiRoiFluoTS: Yes, this could have been its own ROI *except* that then,
%	                  the corners are undefined since this is the 'anti-ROI' -i.e.,
%										all pixels that are NOT in any other ROI and so it would
%										have broken a lot of code. Cell array of timeSeries objects
%                   with one per FOV.
%		antiRoiDffTS: df/f timeSeriesfor anti ROI ; again 1/FOV.
%
%		dffOpts: parameters used by generateDffFromRawFluo (see that method for details)
%		evdetOpts: parameters used by detectEventsFromDff method. (see it for details)
%
%		fileList: stores a list of files fron which data was drawn (cell array) -- 
%             1/FOV.
%		fileFrameIdx: matrix with 2 columns and same # of rows as frames; each row
%		              stores [a b] where a is idx of file within fileList from which
%									this time point comes and b is frame within file.  Again, 1/FOV.
%
%   baseFileName: base file that stores data
%   loadableVar: vars that use loadOnGet (i.e., stored in separate files)
%   loadFlag: -1: don't load [used during breakup saves] ; 0: not loaded but load ; 1: loaded
%
classdef calciumTimeSeriesArray < session.timeSeriesArray 
  % Properties
  properties 
	  numFOVs = 0; % how many fields-of-view
		roiFOVidx = []; % which FOV is this ROI in?
	  roiArray = {}; % roiArray object
		roiActivityStatsHash;
		activeRoiIds; % vector with list of IDs of ROIs that are considered active
		activityFreeImage; % image from epoch with NO activity (based on events)

	  triggerOffsetForTrialInMS = []; % same length as time, trialIndices. 

		roiDepthInMicrons; % Vector containing ROI depth -- matches ids vector
		dffTimeSeriesArray; % timeSeriesArray object but for dFF data
		caPeakEventSeriesArray; % calciumEventSeriesArray object with events
		caPeakTimeSeriesArray; % timeSeriesArray object with only Ca event values 
		eventBasedDffTimeSeriesArray; % timeSeries array for dFF estimated from events

		antiRoiFluoTS = {}; % All pixels except those in ROIs
		antiRoiDffTS = {}; % df/f timeSeriesfor anti ROI 

		dffOpts; % parameters used by generateDffFromRawFluo (see that method for details)
		evdetOpts; % parameters used by detectEventsFromDff method. (see it for details)

		fileList; % stores a list of files fron which data was drawn (cell array)
		fileFrameIdx; % stores [a b] where a is idx of file within fileList from which
									% this time point comes and b is frame within file

    baseFileName = ''; %base file that stores data
    loadableVar = {'dffTimeSeriesArray','caPeakTimeSeriesArray','eventBasedDffTimeSeriesArray'};  %vars that use loadOnGet (i.e., stored in separate files)
    loadFlag = [0 0 0] % -1: don't load [used during breakup saves] ; 0: not loaded but load ; 1: loaded

		improperSave = 1; % notify user of incorrect use of save
  end

  properties(Transient = true) % not saved to file
		originalRoiArray = {}; % kept so you can compare and track changes -- 
		                       % set on load, instantiation
	end

	% Methods -- public ; includes plotters
  methods (Access = public)
	  %
	  % Constructor
		%
    function obj = calciumTimeSeriesArray(tsCellArray, newTrialIndices, newRoiArray, skipSort)

		  % empty?
			trialIndicesPassed = [];
			roiArrayPassed = {};
      activeRoiIds = [];
			antiRoiFluoTS = {};
			antiRoiDffTS = {};
			triggerOffsetForTrialInMS = [];
			fileFrameIdx = {};
			dffOpts = [];
			evdetOpts = [];
			activityFreeImage = {};
      roiActivityStatsHash = hash();

			if (nargin < 1)
			  tsCellArray = {};
			end

			if (nargin >= 3) % more
			  trialIndicesPassed = newTrialIndices;
				roiArrayPassed = newRoiArray;
			end

			% skip sort? default no
			if (nargin < 4)
			  skipSort = 0;
			end

      % call superclass contructor -- SKIP SORT -- we keep it inhouse YO
			obj = obj@session.timeSeriesArray(tsCellArray, trialIndicesPassed, [], {}, [], [], [], 1);
		  obj.loading = 0;
			obj.roiArray = roiArrayPassed;
			for f=1:length(roiArrayPassed)
				if (isobject(roiArrayPassed{f}))
					obj.originalRoiArray{f} = roiArrayPassed{f}.copy();
				end
			end
			obj.numFOVs = length(obj.roiArray);

			% sort by time -- this ensures a lot of sort-dependent methods will work(!)
			if (~skipSort)
				obj.sortByTime();
			end

			% assign default settings for dff
			obj.dffOpts.actParams.cofThresh = 0.15;
			obj.dffOpts.actParams.nabThresh = 0.005;
			obj.dffOpts.actParams.forceRedo = 1;
			obj.dffOpts.fZeroFilterParams.timeUnit = obj.timeUnit;
			obj.dffOpts.fZeroFilterParams.filterType = 'quantile';
			obj.dffOpts.fZeroFilterParams.filterSizeSeconds = 60;
			obj.dffOpts.fZeroFilterParams.quantileThresh = [];

			% assign default settings for event detection
			obj.evdetOpts.timeUnit = obj.timeUnit;
			obj.evdetOpts.tausInDt = 3:30;
			obj.evdetOpts.tRiseInDt = 1:5;
			obj.evdetOpts.initThreshSF = [1.5 2 2.5];
			obj.evdetOpts.debug = 0;
			obj.evdetOpts.minFitRawCorr = 0.25;
			obj.evdetOpts.fitResidualSDThresh = 2;
		end

		% Wrapper for generateDffFromRawFluo that populates dffTimeSeriesArray
    obj = updateDff(obj)

    % Wrapper that runs event detection
    obj = updateEvents(obj)

		% returns indices of rois with various activity levels ; populates roiActivityStatsHash
		obj = getRoiActivityStatistics(obj, params)

    % runs best dff computation and event detection
	  obj =	runBestPracticesDffAndEvdet(obj, params)
   
		% Generates a simple raw test plot for event detection evaluation 
		plotEvents(obj, tsaId)

		% Sorts class by time
	  obj = sortByTime(obj)
   
	  % strips nan 
		obj = stripNanTrials(obj)
   
	  % removes trials 
		obj = deleteTrials(obj, trialIds, dontRedoDffEv)

		% blanks trials for specified roi
		obj = blankTrials(obj, roiId, trialIds)

    % will recompute raw fluo for changed ROIs
    obj = regenerateChangedRois(obj, rerunBestPracticesDffAndEvdet, saveRoiFile)

		% returns frame indices of frames that have no events
		frameIdx = getEventFreeFrameIndices(obj, nFrames, roiIds)

		% returns an image stack consisting of data from specified frames
    im = getRawImageFrames(obj, frames, fov)

		% generates an activity-free image (or images for multi FOV)
		obj = generateActivityFreeImage(obj, nActivityFreeFrames, roiIds)

		% gets an image of epoch(s) following event series
		etim = getEventTriggeredImage(obj, iES, responseTimeWindow, fov, ...
		         baselineTimeWindowOrImage, allowOverlap, xES, xTimeWindow)


    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MISC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %
    % Copy
    %
		function cobj = copy(obj)
		  fn = fieldnames(obj);
			cobj = session.calciumTimeSeriesArray();
			doAtEnd = {'time','timeUnit','trialIndices'};
			for f=1:length(fn)
			  if (eval(['isobject(obj.' fn{f} ');']))
				  eval(['cobj.' fn{f} ' = obj.' fn{f} '.copy();']);
				elseif (length(find(strcmp(doAtEnd, fn{f}))) == 0)
				  eval(['cobj.' fn{f} ' = obj.' fn{f} ';']);
				end
			end

			for d=1:length(doAtEnd)
			  eval(['cobj.' doAtEnd{d} ' = obj.' doAtEnd{d} ';']);
			end

			% and just to make sure you don't overwrite things(!)
			cobj.baseFileName = strrep(obj.baseFileName, '.mat', '_copy.mat');
		end

		% Merge with another
    obj = mergeWith(obj, nObj)

		%
		% Light copy -- that is, without large sub-objects
		%
    function lightObj = lightCopy(obj)
      lightObj = loadonget_lightcopy(obj);
    end

		%
		% For saving to file
		%
		function obj = saveToFile(obj, baseFileName)
		  if (nargin == 1) ; baseFileName = obj.baseFileName ; end
			obj.improperSave = 0;
      obj = loadonget_savetofile(obj, baseFileName);
			obj.improperSave = 1;
		end

    %
		% you should not use this!
		%
		function obj = saveobj(a)
		  if (a.improperSave)
				disp('calciumTimeSeriesArray.save::you should call saveToFile to save, not save!!');
			end
			obj = a;
		end

    %
		% save the loadOnGet stuff
		%
		function saveLoadOnGet(obj, varName)
		  loadonget_saveloadonget(obj, varName);
		end

    % 
		% loads a file-stored variable
		% 
		function value = loadOnGet(obj, varName)
			value =	loadonget_loadonget(obj, varName);
		end

	end

  % Static -- generate from file etc.
  methods (Static)
	  % this is called on load
	  function obj = loadobj(a) 
		  a.loading = 1;
		  a = loadonget_loadobj(a);

		  for f=1:length(a.roiArray)
				if (isobject(a.roiArray{f}))
					a.originalRoiArray{f} = a.roiArray{f}.copy();
				end
			end
			obj = a;
			obj.loading = 0;
	  end

    % generate calclium time series array from raw data
    obj = generateCalciumTimeSeriesArray(roiArray, dataPath, dataWC, ignoreSessionStats, dataFileList, dataFileTrial)

		% computes df/f from raw fluorescence trace, returning a timeSeriesArray
		%  object with dF/F
		dffTSA = generateDffFromRawFluo(fTSA, dffOpts)

		% derives events in a timeSeriesArray (obj.dffTimeSeriesArray) and return a calciumEventSeriesArray
		cesaObj = detectEventsFromDff(obj, evdetOpts)

		% determines peak times, values and start/end times of events over a data matrix
		%  given thresholds, etc.
		[peakTimes peakValues startTimes endTimes] = detectEventsViaThresh(dataMatrix, timeVec, eventThresh, startThresh, endThresh, minEvDur)

		% Pulls goodness-of-fit based time constants
		[riseTimes decayTimes] = getGOFRestrictedTimeConstantsS(peakTimes, valueMatrix, timeVec, timeUnit)

		% pulls t1/2 based time constants
    [riseTimes decayTimes] = getTHalfBasedTimeConstantsS(startTimes, endTimes, peakTimes, valueMatrix, timeVec)
	end


  % Methods -- set/get/basic variable manipulation stuff
	methods 
	  % ensure that time, trialIndices and time are assigned properly
	  function obj = set.dffTimeSeriesArray(obj, newDffTimeSeriesArray)
		  newDffTimeSeriesArray.time = obj.time;
			newDffTimeSeriesArray.trialIndices = obj.trialIndices;
			obj.dffTimeSeriesArray = newDffTimeSeriesArray;
		end

	  % ensure that time, trialIndices and time are assigned properly
	  function obj = set.caPeakTimeSeriesArray(obj, newCaPeakTimeSeriesArray)
		  newCaPeakTimeSeriesArray.time = obj.time;
			newCaPeakTimeSeriesArray.trialIndices = obj.trialIndices;
			obj.caPeakTimeSeriesArray = newCaPeakTimeSeriesArray;
		end

	  % ensure that time, trialIndices and time are assigned properly
	  function obj = set.eventBasedDffTimeSeriesArray(obj, newEventBasedDffTimeSeriesArray)
			 % timeSeries array for dFF estimated from events
    	newEventBasedDffTimeSeriesArray.time = obj.time;
    	newEventBasedDffTimeSeriesArray.trialIndices = obj.trialIndices;
			obj.eventBasedDffTimeSeriesArray= newEventBasedDffTimeSeriesArray;
		end

		% baseFileName -- relativbe root data path
    function obj = set.baseFileName(obj, newBaseFileName)
		  obj.baseFileName = init_root_data_path(newBaseFileName);
    end

    % returns the baseFileName -- WITH global path !
    function value = get.baseFileName(obj)
      value = assign_root_data_path(obj.baseFileName);
    end

    % for loadOnGet support
		function value = get.dffTimeSeriesArray(obj)
		  if (~isobject(obj.dffTimeSeriesArray)) % not object? try to load it 
		    value = loadOnGet(obj, 'dffTimeSeriesArray');
				obj.dffTimeSeriesArray = value;
			else
				idx = find(strcmp(obj.loadableVar ,'dffTimeSeriesArray'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.dffTimeSeriesArray;
		end

    % for loadOnGet support
		function value = get.caPeakTimeSeriesArray(obj)
		  if (~isobject(obj.caPeakTimeSeriesArray)) % not object? try to load it 
		    value = loadOnGet(obj, 'caPeakTimeSeriesArray');
				obj.caPeakTimeSeriesArray = value;
			else
				idx = find(strcmp(obj.loadableVar ,'caPeakTimeSeriesArray'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.caPeakTimeSeriesArray;
		end

    % for loadOnGet support
		function value = get.eventBasedDffTimeSeriesArray(obj)
		  if (~isobject(obj.eventBasedDffTimeSeriesArray)) % not object? try to load it 
		    value = loadOnGet(obj, 'eventBasedDffTimeSeriesArray');
				obj.eventBasedDffTimeSeriesArray = value;
			else
				idx = find(strcmp(obj.loadableVar ,'eventBasedDffTimeSeriesArray'));
				obj.loadFlag(idx) = 1;
			end
			value = obj.eventBasedDffTimeSeriesArray;
	 end


  end

	% override set methods 
	methods (Access = protected)
    % ensure timechangse propagate
	  function subclassSetTime(obj)
			if (isobject(obj.dffTimeSeriesArray)) ; obj.dffTimeSeriesArray.time = obj.time; end
			if (isobject(obj.caPeakTimeSeriesArray)) ; obj.caPeakTimeSeriesArray.time = obj.time; end
			if (isobject(obj.eventBasedDffTimeSeriesArray)) ; obj.eventBasedDffTimeSeriesArray.time = obj.time; end
			for f=1:obj.numFOVs
				if (length(obj.antiRoiFluoTS) > 0 && isobject(obj.antiRoiFluoTS{f})) ; obj.antiRoiFluoTS{f}.time= obj.time; end
				if (length(obj.antiRoiDffTS) > 0 && isobject(obj.antiRoiDffTS{f})) ; obj.antiRoiDffTS{f}.time = obj.time ; end
			end
		end

    % ensure timeUnit changse propagate
	  function subclassSetTimeUnit(obj)
			if (isobject(obj.dffTimeSeriesArray)) ; obj.dffTimeSeriesArray.timeUnit = obj.timeUnit; end
			if (isobject(obj.caPeakTimeSeriesArray)) ; obj.caPeakTimeSeriesArray.timeUnit = obj.timeUnit; end
			if (isobject(obj.eventBasedDffTimeSeriesArray)) ; obj.eventBasedDffTimeSeriesArray.timeUnit = obj.timeUnit; end
			for f=1:obj.numFOVs
				if (length(obj.antiRoiFluoTS) > 0 && isobject(obj.antiRoiFluoTS{f})) ; obj.antiRoiFluoTS{f}.timeUnit= obj.timeUnit; end
				if (length(obj.antiRoiDffTS) > 0 && isobject(obj.antiRoiDffTS{f})) ; obj.antiRoiDffTS{f}.timeUnit = obj.timeUnit ; end
			end
		end

    % ensure trialIndices changse propagate
	  function subclassSetTrialIndices(obj)
			if (isobject(obj.dffTimeSeriesArray)) ; obj.dffTimeSeriesArray.trialIndices = obj.trialIndices; end
			if (isobject(obj.caPeakTimeSeriesArray)) ; obj.caPeakTimeSeriesArray.trialIndices = obj.trialIndices; end
			if (isobject(obj.eventBasedDffTimeSeriesArray)) ; obj.eventBasedDffTimeSeriesArray.trialIndices = obj.trialIndices; end
		end

	end
end
