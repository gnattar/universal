%
% This is a static method that computes df/f and returns a timeSeriesArray.
%
% USAGE:
%
%   dffTSA = session.calciumTimeSeriesArray.generateDffFromRawFluo(fTSA, dffOpts)
%
% ARGUMENTS:
%
%   fTSA: timeSeriesArray object with the raw fluorescence data ; can also be
%         a timeSeries
%   dffOpts: structure with many options on to how to proceed:
%     dffOpts.fZeroFilterParams: options passed to session.timeSeries.filterS  
%                          to compute f-zero.  Note that if method is 'quantile', 
%                          it will use different quantiles for active, inactive,
%                          and hyperActive cells (see getRoiActivityStatistics).
%     dffOpts.actParams: parameters to getRoiActivityStatistics if you wish to 
%                        re-call this method (note that if you pass this, 
%                        forceRedo is enabled).
%
% RETURNS:
%
%   dffTSA: timeSeriesArray object with same time basis as fTSA and same number
%           of timeSeries, but now with dff.  If you pass timeSeries, this will
%           return one.
%
%
function dffTSA = generateDffFromRawFluo(fTSA, dffOpts)

  %% --- parse user input

	% defaults 
	fZeroFilterParams.timeUnit = session.timeSeries.millisecond;
	fZeroFilterParams.filterType = 'quantile';
	fZeroFilterParams.filterSizeSeconds = 60; % in SECONDS
	fZeroFilterParams.quantileThresh = [];
	actParams = [];

	% parse user-passed
	if (isstruct(dffOpts))
		eval(assign_vars_from_struct(dffOpts,'dffOpts'));
	end

	% what is fTSA?
	isTSA = 1;
  if (strcmp(class(fTSA),'session.timeSeries') | strcmp(class(fTSA),'session.calciumTimeSeries'))
	  isTSA = 0;
	end

	%% --- setup

	% recompute statistics?
	if (isstruct(actParams) && isTSA)
	  actParams.forceRedo = 1;
		fTSA.getRoiActivityStatistics(actParams);
	end

	% quantile filter requires you assign thresholds per-vector
	if (strcmp(fZeroFilterParams.filterType,'quantile') && length(fZeroFilterParams.quantileThresh) == 0)
	  if (strcmp(class(fTSA), 'session.calciumTimeSeriesArray'))
			hyperactiveIdx = fTSA.roiActivityStatsHash.get('hyperactiveIdx');
			activeIdx = fTSA.roiActivityStatsHash.get('activeIdx');
			inactiveIdx = fTSA.roiActivityStatsHash.get('inactiveIdx');
			fZeroFilterParams.quantileThresh = 0.25*ones(1,size(fTSA.valueMatrix,1));
			fZeroFilterParams.quantileThresh(activeIdx) = 0.1;
			fZeroFilterParams.quantileThresh(hyperactiveIdx) = 0.05;
		else
		  fZeroFilterParams.quantileThresh = 0.25;
		end
	end

	% pull data based on class
	if (isTSA)
	  time = fTSA.time;
		valueMatrix = fTSA.valueMatrix;
	else % timeseries
	  time = fTSA.time;
		valueMatrix = fTSA.value;
	end

	%% --- fzero computation & implementation (i.e., division to get dff)
	fZeroMat = session.timeSeries.filterS(time, valueMatrix, fZeroFilterParams);
	dffMat = (valueMatrix - fZeroMat)./fZeroMat;
  dffMat(find(isinf(dffMat))) = nan;

	%% --- subtraction / correction of trace 

	%% --- build output object
	if (isTSA)
		newTSs = {};
		for r=1:size(dffMat,1);
			newTSs{r} = session.timeSeries(fTSA.time, 1, dffMat(r,:), fTSA.ids(r), ...
				['dF/F ' char(fTSA.idStrs{r})], 0, 'Generated by generateDffFromRawFluo');
		end
		dffTSA = session.timeSeriesArray(newTSs, fTSA.trialIndices); 
	else % just TS
		dffTSA = session.timeSeries(time, 1, dffMat, fTSA.id, ...
			['dF/F ' char(fTSA.idStr)], 0, 'Generated by generateDffFromRawFluo');
	end

